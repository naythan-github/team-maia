#!/usr/bin/env python3
"""
PMP Vulnerability Extractor - CVE and Vulnerability Tracking
Production-grade extractor for ManageEngine PMP vulnerability data

Features:
- CVE-to-patch mapping from /api/1.4/patch/vulnerabilities
- CVSS score tracking for risk assessment
- SQLite storage with unified schema
- OAuth 2.0 authentication
- Error handling with retry logic

Author: SRE Principal Engineer Agent
Date: 2025-01-15
Version: 1.0
Sprint: SPRINT-PMP-UNIFIED-001
Phase: P3 - Missing API Endpoints
"""

import sqlite3
import json
import time
import logging
from pathlib import Path
from typing import Optional, List, Dict
from datetime import datetime

# Import existing OAuth manager
try:
    from claude.tools.pmp.pmp_oauth_manager import PMPOAuthManager
except ImportError:
    from pmp_oauth_manager import PMPOAuthManager


# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


class PMPVulnerabilityExtractor:
    """
    ManageEngine PMP vulnerability extractor with SQLite storage

    Usage:
        extractor = PMPVulnerabilityExtractor()
        snapshot_id = extractor.extract_vulnerabilities()
        print(f"Extracted vulnerabilities in snapshot {snapshot_id}")
    """

    def __init__(self, db_path: Optional[Path] = None):
        """
        Initialize extractor with OAuth manager and database

        Args:
            db_path: Path to SQLite database (default: ~/.maia/databases/intelligence/pmp_config.db)
        """
        # Initialize OAuth manager
        self.oauth_manager = PMPOAuthManager()

        # Database path
        if db_path is None:
            db_path = Path.home() / ".maia/databases/intelligence/pmp_config.db"
        self.db_path = Path(db_path)

        # Ensure database directory exists
        self.db_path.parent.mkdir(parents=True, exist_ok=True)

        # Initialize database schema
        self.init_database()

        logger.info("pmp_vulnerability_extractor_initialized", extra={
            "db_path": str(self.db_path),
            "oauth_configured": True
        })

    def init_database(self):
        """Initialize database schema from SQL file"""
        schema_file = Path(__file__).parent / "pmp_unified_schema.sql"

        if not schema_file.exists():
            raise FileNotFoundError(f"Schema file not found: {schema_file}")

        # Read and execute schema
        schema_sql = schema_file.read_text()

        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        # Execute schema (handles IF NOT EXISTS, so safe to run multiple times)
        cursor.executescript(schema_sql)

        conn.commit()
        conn.close()

        # Set file permissions (owner read/write only)
        self.db_path.chmod(0o600)

        logger.info("database_schema_initialized", extra={
            "db_path": str(self.db_path),
            "schema_version": 1
        })

    def extract_vulnerabilities(self) -> Optional[int]:
        """
        Extract vulnerability data from PMP API /api/1.4/patch/vulnerabilities

        Returns:
            snapshot_id if successful, None if failed

        Raises:
            RuntimeError: If extraction fails after retries
        """
        start_time = time.time()
        snapshot_id = None
        status = 'failed'
        error_message = None

        try:
            logger.info("vulnerability_extraction_started")

            # Call PMP API /api/1.4/patch/vulnerabilities
            response = self.oauth_manager.api_request('GET', '/api/1.4/patch/vulnerabilities')

            if response.status_code != 200:
                raise RuntimeError(f"API returned {response.status_code}: {response.text[:200]}")

            # Parse response
            data = response.json()

            # Extract vulnerabilities list
            vulnerabilities = data['message_response']['vulnerabilities']

            # Create snapshot
            duration_ms = int((time.time() - start_time) * 1000)
            snapshot_id = self.create_snapshot(status='success', duration_ms=duration_ms)

            # Insert vulnerabilities
            inserted = self.insert_vulnerabilities(snapshot_id, vulnerabilities)

            logger.info("vulnerability_extraction_success", extra={
                "snapshot_id": snapshot_id,
                "vulnerabilities_count": inserted,
                "duration_ms": duration_ms
            })

            return snapshot_id

        except Exception as e:
            error_message = str(e)
            status = 'failed'

            logger.error("vulnerability_extraction_failed", extra={
                "error": error_message
            }, exc_info=True)

            # Create failed snapshot record for audit trail
            duration_ms = int((time.time() - start_time) * 1000)
            snapshot_id = self.create_snapshot(status='failed', duration_ms=duration_ms, error_message=error_message)

            raise

    def create_snapshot(self, status: str, duration_ms: int, error_message: Optional[str] = None) -> int:
        """
        Create snapshot record in database

        Args:
            status: 'success', 'partial', or 'failed'
            duration_ms: Extraction duration in milliseconds
            error_message: Error message if status = 'failed'

        Returns:
            snapshot_id
        """
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        try:
            cursor.execute("""
                INSERT INTO snapshots (api_version, extraction_duration_ms, status, error_message)
                VALUES (?, ?, ?, ?)
            """, ('1.4', duration_ms, status, error_message))

            snapshot_id = cursor.lastrowid
            conn.commit()

            return snapshot_id

        finally:
            conn.close()

    def insert_vulnerabilities(self, snapshot_id: int, vulnerabilities: List[Dict]) -> int:
        """
        Insert vulnerabilities into database

        Args:
            snapshot_id: Snapshot ID to associate vulnerabilities with
            vulnerabilities: List of vulnerability dictionaries from API

        Returns:
            Number of vulnerabilities inserted
        """
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        inserted = 0

        try:
            for vuln in vulnerabilities:
                # Extract CVE year from CVE ID (e.g., CVE-2024-12345 -> 2024)
                cve_id = vuln.get('cve_id', '')
                cve_year = None
                if cve_id.startswith('CVE-'):
                    try:
                        cve_year = int(cve_id.split('-')[1])
                    except (IndexError, ValueError):
                        pass

                # Convert patch_ids list to comma-separated string
                patch_ids = vuln.get('patch_ids', [])
                if isinstance(patch_ids, list):
                    patch_ids_str = ','.join(str(pid) for pid in patch_ids)
                else:
                    patch_ids_str = str(patch_ids)

                cursor.execute("""
                    INSERT OR REPLACE INTO vulnerabilities (
                        snapshot_id, cve_id, cve_year, cvss_score, cvss_severity,
                        pmp_patch_ids, description, published_date
                    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
                """, (
                    snapshot_id,
                    vuln.get('cve_id'),
                    cve_year,
                    vuln.get('cvss_score'),
                    vuln.get('cvss_severity'),
                    patch_ids_str,
                    vuln.get('description'),
                    vuln.get('published_date')
                ))

                inserted += 1

            conn.commit()

            logger.info("vulnerabilities_inserted", extra={
                "snapshot_id": snapshot_id,
                "inserted_count": inserted
            })

            return inserted

        except Exception as e:
            conn.rollback()
            logger.error("vulnerability_insert_failed", extra={
                "snapshot_id": snapshot_id,
                "error": str(e)
            })
            raise

        finally:
            conn.close()

    def get_latest_vulnerabilities(self) -> List[Dict]:
        """
        Get vulnerabilities from most recent successful snapshot

        Returns:
            List of vulnerability dictionaries
        """
        conn = sqlite3.connect(self.db_path)
        conn.row_factory = sqlite3.Row
        cursor = conn.cursor()

        try:
            cursor.execute("""
                SELECT v.*
                FROM vulnerabilities v
                INNER JOIN (
                    SELECT MAX(snapshot_id) as latest_snapshot_id
                    FROM snapshots
                    WHERE status = 'success'
                ) latest ON v.snapshot_id = latest.latest_snapshot_id
                ORDER BY v.cvss_score DESC
            """)

            return [dict(row) for row in cursor.fetchall()]

        finally:
            conn.close()

    def get_critical_vulnerabilities(self, min_cvss_score: float = 9.0) -> List[Dict]:
        """
        Get critical vulnerabilities (CVSS >= threshold)

        Args:
            min_cvss_score: Minimum CVSS score (default: 9.0)

        Returns:
            List of critical vulnerability dictionaries
        """
        conn = sqlite3.connect(self.db_path)
        conn.row_factory = sqlite3.Row
        cursor = conn.cursor()

        try:
            cursor.execute("""
                SELECT v.*
                FROM vulnerabilities v
                INNER JOIN (
                    SELECT MAX(snapshot_id) as latest_snapshot_id
                    FROM snapshots
                    WHERE status = 'success'
                ) latest ON v.snapshot_id = latest.latest_snapshot_id
                WHERE v.cvss_score >= ?
                ORDER BY v.cvss_score DESC
            """, (min_cvss_score,))

            return [dict(row) for row in cursor.fetchall()]

        finally:
            conn.close()


def main():
    """CLI interface for vulnerability extractor"""
    import argparse
    import sys

    parser = argparse.ArgumentParser(description="PMP Vulnerability Extractor")
    parser.add_argument('command', choices=['extract', 'list', 'critical'],
                       help='Command to execute')
    parser.add_argument('--db', type=str,
                       help='Path to SQLite database (default: ~/.maia/databases/intelligence/pmp_config.db)')
    parser.add_argument('--min-cvss', type=float, default=9.0,
                       help='Minimum CVSS score for critical filter (default: 9.0)')

    args = parser.parse_args()

    # Initialize extractor
    db_path = Path(args.db) if args.db else None
    extractor = PMPVulnerabilityExtractor(db_path=db_path)

    if args.command == 'extract':
        print("Extracting vulnerability data from PMP API...")
        try:
            snapshot_id = extractor.extract_vulnerabilities()
            print(f"Snapshot {snapshot_id} extracted successfully")

            # Show summary
            vulns = extractor.get_latest_vulnerabilities()
            critical_count = sum(1 for v in vulns if v['cvss_severity'] == 'CRITICAL')
            high_count = sum(1 for v in vulns if v['cvss_severity'] == 'HIGH')

            print(f"\nSummary:")
            print(f"  Total Vulnerabilities: {len(vulns)}")
            print(f"  Critical: {critical_count}")
            print(f"  High: {high_count}")

        except Exception as e:
            print(f"Extraction failed: {e}")
            sys.exit(1)

    elif args.command == 'list':
        print("Latest Vulnerabilities:")
        vulns = extractor.get_latest_vulnerabilities()

        if vulns:
            print(f"\n{'CVE ID':<20} {'CVSS':>6} {'Severity':<10} {'Patches':>8}")
            print("-" * 50)

            for vuln in vulns[:20]:  # Show top 20
                cve_id = vuln['cve_id']
                cvss = vuln['cvss_score'] or 0.0
                severity = vuln['cvss_severity'] or 'UNKNOWN'
                patch_count = len(vuln['pmp_patch_ids'].split(',')) if vuln['pmp_patch_ids'] else 0

                print(f"{cve_id:<20} {cvss:>6.1f} {severity:<10} {patch_count:>8}")
        else:
            print("  No vulnerabilities found")

    elif args.command == 'critical':
        print(f"Critical Vulnerabilities (CVSS >= {args.min_cvss}):")
        vulns = extractor.get_critical_vulnerabilities(min_cvss_score=args.min_cvss)

        if vulns:
            print(f"\n{'CVE ID':<20} {'CVSS':>6} {'Description':<50}")
            print("-" * 80)

            for vuln in vulns:
                cve_id = vuln['cve_id']
                cvss = vuln['cvss_score'] or 0.0
                desc = (vuln['description'] or '')[:50]

                print(f"{cve_id:<20} {cvss:>6.1f} {desc:<50}")
        else:
            print(f"  No vulnerabilities with CVSS >= {args.min_cvss}")


if __name__ == '__main__':
    main()
